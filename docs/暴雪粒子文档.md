# 暴雪粒子文档

1. # 粒子文档 - 发射器局部空间组件

   此组件指定发射器的参考系。仅当发射器附加到实体时才生效。当“position”为真时，粒子将在实体空间中模拟；否则，将在世界空间中模拟。旋转的工作原理相同。两者的默认值均为假，这意味着粒子相对于发射器发射，然后独立于发射器进行模拟。请注意，“rotation = true”和“position = false”是无效选项。“Velocity”会将发射器的速度添加到粒子的初始速度中。

   JSON

   ```json
   "minecraft:emitter_local_space": {
       "position": <bool>
       "rotation": <bool>
       "velocity": <bool>
   }
   ```

2. # 粒子系统文档 - 发射器初始化组件

   该组件允许发射器在创建时运行一些 Molang 代码，主要是为了填充以后要使用的任何 Molang 变量。

   JSON

   ```json
   "minecraft:emitter_initialization": {
     "creation_expression": <molang>, // this is run once at emitter startup
     "per_update_expression": <molang> // this is run once per emitter update
   }
   ```

3. # 粒子文档 - 发射速率瞬时组件

   所有粒子同时释放，除非发射器循环，否则不会再释放更多粒子。

   JSON

   ```json
   "minecraft:emitter_rate_instant": {
       // this many particles are emitted at once
       // evaluated once per particle emitter loop
       "num_particles": <float/molang> <default:10>
   }
   ```

4. # Particle Documentation - Emitter Rate Steady component

   Particles come out at a steady or Molang rate over time.

   JSON

   ```json
   "minecraft:emitter_rate_steady": {
       // how often a particle is emitted, in particles/sec
       // evaluated once per particle emitted
       "spawn_rate": <float/molang> <default:1>
   
       // maximum number of particles that can be active at once for this emitter
       // evaluated once per particle emitter loop
       "max_particles": <float/molang> <default:50>
   }
   ```

5.Particle Documentation - Emitter Rate Manual component

Particle emission will occur only when the emitter is told to emit via the game itself. This is mostly used by legacy particle effects.

JSON

```json
"minecraft:emitter_rate_manual": {
    // evaluated once per particle emitted
    "max_particles": <float/molang> <default:50>
}
```

6.Particle Documentation - Emitter Lifetime Looping component

Emitter will loop until it is removed.

JSON

```json
"minecraft:emitter_lifetime_looping": {

    // emitter will emit particles for this time per loop
    // evaluated once per particle emitter loop
    "active_time": <float/molang> <default:10>

    // emitter will pause emitting particles for this time per loop
    // evaluated once per particle emitter loop
    "sleep_time": <float/molang> <default:0>
}
```

7. Particle Documentation - Emitter Lifetime Once component

Emitter will execute once, and once the lifetime ends or the number of particles allowed to emit have emitted, the emitter expires.

JSON

```json
"minecraft:emitter_lifetime_once": {
    // how long the particles emit for
    // evaluated once
    "active_time": <float/molang> <default:10>
}
```

8. # Particle Documentation - Emitter Lifetime Expression component

   Emitter will turn 'on' when the activation expression is non-zero, and will turn 'off' when it's zero. This is useful for situations like driving an entity-attached emitter from an entity variable.

   JSON

   ```json
   "minecraft:emitter_lifetime_expression": {
       // When the expression is non-zero, the emitter will emit particles.
       // Evaluated every frame
       "activation_expression": <float/molang> <default:1>
   
       // Emitter will expire if the expression is non-zero.
       // Evaluated every frame
       "expiration_expression": <float/molang> <default:0>
   }
   ```

9. # Particle Documentation - Emitter Lifetime Events component

   Allows for lifetime events on the emitter to trigger certain events.

   JSON

   ```json
   "minecraft:emitter_lifetime_events": {
         // all events use the event names in the event section
         // all events can be an array or a string
         "creation_event": [ <string>, ...] // fires when the emitter is created
         "creation_event": <string>
         "expiration_event": [ <string>, ...] // fires when the emitter expires (does not wait for particles to expire too)
         "expiration_event": <string>
   
         // event timeline
         "timeline: {
           // a series of times, e.g. 0.0 or 1.0, that trigger the event
           // these get fired on every loop the emitter goes through
           // "time" is the time, e.g. one line might be:
           // "0.4": "event"
           "time": [ <string>, ... ]
           "time": <string>
         }
       }
   
       // travel_distance_events
       "travel_distance_events: {
           // a series of distances, e.g. 0.0 or 1.0, that trigger the event
           // these get fired when the emitter has moved by the specified input
         // distance, e.g. one line might be:
           // "0.4": "event"
           "distance": [ <string>, ... ]
           "distance": <string>
       }
   
       // looping_travel_distance_events
       "looping_travel_distance_events: [
           // a series of events that occur at set intervals
         // these get fired every time the emitter has moved the specified input
         // distance from the last time it was fired.
         // An example for how to format these events would be:
           // {
           //   "distance": 1.0,
           //   "effects": [ "effect_one" ]
           // },
           // {
           //   "distance": 2.0,
           //   "effects": [ "effect_two" ]
           // }
     //
     // Note that "effect_one" and "effect_two" must be defined events within the particle_effect
       ]
   
   }
   ```

10. # Particle Documentation - Emitter Shape Point component

    All particles come out of a point offset from the emitter.

    JSON

    ```json
    "minecraft:emitter_shape_point": {
        // specifies the offset from the emitter to emit the particles
        // evaluated once per particle emitted
        "offset": [<float/molang>, <float/molang>, <float/molang>] <default:[0, 0, 0]>
    
        // specifies the direction of particles.
        // evaluated once per particle emitted
        "direction": [<float/molang>, <float/molang>, <float/molang>]
    }
    ```

11. # Particle Documentation - Emitter Shape Sphere component

    All particles come out of a sphere offset from the emitter.

    JSON

    ```json
    "minecraft:emitter_shape_sphere": {
        // specifies the offset from the emitter to emit the particles
        // evaluated once per particle emitted
        "offset": [<float/molang>, <float/molang>, <float/molang>] <default:[0, 0, 0]>
    
        // sphere radius
        // evaluated once per particle emitted
        "radius": <float/molang> <default:1>
    
        // emit only from the surface of the sphere
        "surface_only": <bool> <default:false>
    
        // specifies the direction of particles.  Defaults to "outwards"
        "direction": "inwards" // particle direction towards center of sphere
        "direction": "outwards" // particle direction away from center of sphere
        // evaluated once per particle emitted
        "direction": [<float/molang>, <float/molang>, <float/molang>]
    }
    ```

12. # Particle Documentation - Emitter Shape Box component

    All particles come out of a box of the specified size from the emitter.

    JSON

    ```json
    "minecraft:emitter_shape_box": {
        // specifies the offset from the emitter to emit the particles
        // evaluated once per particle emitted
        "offset": [<float/molang>, <float/molang>, <float/molang>] <default:[0, 0, 0]>
    
        // box dimensions
        // these are the half dimensions, the box is formed centered on the emitter
        // with the box extending in the 3 principal x/y/z axes by these values
        "half_dimensions": [ <float/molang>, <float/molang> <float/molang ],
    
        // emit only from the surface of the sphere
        "surface_only": <bool> <default:false>
    
        // specifies the direction of particles.  Defaults to "outwards"
        // evaluated once per particle emitted
        "direction": "inwards" // particle direction towards center of sphere
        "direction": "outwards" // particle direction away from center of sphere
        "direction": [<float/molang>, <float/molang>, <float/molang>]
    }
    ```

13. # Particle Documentation - Emitter Shape Custom component

    All particles are emitted based on a specified set of Molang expressions.

    JSON

    ```json
    "minecraft:emitter_shape_custom": {
        // specifies the offset from the emitter to emit the particles
        // evaluated once per particle emitted
        "offset": [<float/molang>, <float/molang>, <float/molang>] <default:[0, 0, 0]>
    
        // specifies the direction for the particle
        // evaluated once per particle emitted
        "direction": [<float/molang>, <float/molang>, <float/molang>] <default:[0, 0, 0]
    }
    ```

14. # Particle Documentation - Emitter Shape Entity-AABB component

    All particles come out of the axis-aligned bounding box (AABB) for the entity the emitter is attached to, or the emitter point if no entity.

    JSON

    ```json
    "minecraft:emitter_shape_entity_aabb": {
        // emit only from the surface of the sphere
        "surface_only": <bool> <default:false>
    
        // evaluated once per particle emitted
        // defaults to outwards
        "direction": "inwards" // particle direction towards center of sphere
        "direction": "outwards" // particle direction away from center of sphere
        "direction": [<float/molang>, <float/molang>, <float/molang>] <default:[0, 0, 0]
    }
    ```

15. # Particle Documentation - Emitter Disc component

    This component spawns particles using a disc shape. Particles can be spawned inside the shape, or on its outer perimeter.

    JSON

    ```json
    "minecraft:emitter_shape_disc": {
        // specifies the normal of the disc plane, the disc will be perpendicular to this direction
        // defaults to [ 0, 1, 0 ]
        "plane_normal": "x", // this variant has the normal in the x axis
        "plane_normal": "y", // this variant has the normal in the y axis
        "plane_normal": "z", // this variant has the normal in the z axis
        "plane_normal": [ <float/molang>, <float/molang>, <float/molang> ], // custom direction for the normal
    
        // specifies the offset from the emitter to emit the particles
        // evaluated once per particle emitted
        "offset": [<float/molang>, <float/molang>, <float/molang>] <default:[0, 0, 0]>
    
        // disc radius
        // evaluated once per particle emitted
        "radius": <float/molang> <default:1>
    
        // emit only from the edge of the disc
        "surface_only": <bool> <default:false>
    
        // specifies the direction of particles.  Defaults to "outwards"
        "direction": "inwards" // particle direction towards center of disc
        "direction": "outwards" // particle direction away from center of disc
        // evaluated once per particle emitted
        "direction": [<float/molang>, <float/molang>, <float/molang>]
    }
    ```

16. # Particle Documentation - Particle Initial Speed component

    Starts the particle with a specified speed, using the direction specified by the emitter shape.

    JSON

    ```json
    // evaluated once
    "minecraft:particle_initial_speed": <float/molang> <default:0>
    
    "minecraft:particle_initial_speed" [<float/molang>, <float/molang>, <float/molang>],
    ```

17. 

# Particle Documentation - Particle Initial Spin component

Starts the particle with a specified orientation and rotation rate.

JSON

```json
"minecraft:particle_initial_spin": {
    // specifies the initial rotation in degrees
    // evaluated once
    "rotation": <float/molang> <default:0>

    // specifies the spin rate in degrees/second
    // evaluated once
    "rotation_rate": <float/molang> <default:0>
}
```

18. # Particle Documentation - Particle Initialization component

    Starts the particle with a specified render expression.

    JSON

    ```json
    "minecraft:particle_initialization": {
        "per_render_expression": "variable.tint = variable.particle_random_1 * 0.5 + 0.5;"
    }
    ```

19. # Particle Documentation - Particle Motion Dynamic component

    This component specifies the dynamic properties of the particle, from a simulation standpoint what forces act upon the particle? These dynamics alter the velocity of the particle, which is a combination of the direction of the particle and the speed. Particle direction will always be in the direction of the velocity of the particle.

    JSON

    ```json
    "minecraft:particle_motion_dynamic": {
        // the linear acceleration applied to the particle, defaults to [0, 0, 0].
        // Units are blocks/sec/sec
        // An example would be gravity which is [0, -9.8, 0]
        // evaluated every frame
        "linear_acceleration": [<float/molang>, <float/molang>, <float/molang>],
    
        // using the equation:
        // acceleration = -linear_drag_coefficient*velocity
        // where velocity is the current direction times speed
        // Think of this as air-drag.  The higher the value, the more drag
        // evaluated every frame
        "linear_drag_coefficient": <float/molang> <default:0>
    
        // acceleration applies to the rotation speed of the particle
        // think of a disc spinning up or a smoke puff that starts rotating
        // but slows down over time
        // evaluated every frame
        // acceleration is in degrees/sec/sec
        "rotation_acceleration" <float/molang> <default:0>
    
        // drag applied to slow down rotation
        // equation is rotation_acceleration += -rotation_rate*rotation_drag_coefficient
        // useful to slow a rotation, or to limit the rotation acceleration
        // Think of a disc that speeds up (acceleration)
        // but reaches a terminal speed (drag)
        // Another use is if you have a particle growing in size, having
        // the rotation slow down due to drag can add "weight" to the particle's
        // motion
        "rotation_drag_coefficient" <float/molang> <default:0>
    }
    ```

20. # Particle Documentation - Particle Motion Parametric component

    This component directly controls the particle.

     Note

    This component won't work for either manually-emitted particles, or entity-based particle emitters that aren't in local space.

    JSON

    ```json
    "minecraft:particle_motion_parametric": {
        // directly set the position relative to the emitter.
        // E.g. a spiral might be:
        // "relative_position": ["Math.cos(Params.LifeTime)", 1.0,
        //                       "Math.sin(Params.Lifetime)"]
        // defaults to [0, 0, 0]
        // evaluated every frame
        "relative_position": [<float/molang> <float/molang> <float/molang>]
    
        // directly set the 3d direction of the particle
        // doesn't affect direction if not specified
        // evaluated every frame
        "direction": [<float/molang> <float/molang> <float/molang]
    
        // directly set the rotation of the particle
        // evaluated every frame
        "rotation": <float/molang> <default:0>
    }}
    ```

21. # Particle Documentation - Particle Motion Collision component

    This component enables collisions between the terrain and the particle. Collision detection in Minecraft consists of detecting an intersection, moving to a nearby non-intersecting point for the particle (if possible), and setting its direction to not be aimed towards the collision (usually perpendicular to the collision surface).

     Important

    If this component doesn't exist, there will be no collision.

    JSON

    ```json
    "minecraft:particle_motion_collision": {
        // enables collision when true/non-zero.
        // evaluated every frame
        "enabled": <bool/molang> <default:true>
    
        // alters the speed of the particle when it has collided
        // useful for emulating friction/drag when colliding, e.g a particle
        // that hits the ground would slow to a stop.
        // This drag slows down the particle by this amount in blocks/sec
        // when in contact
        "collision_drag": <float>
    
        // used for bouncing/not-bouncing
        // Set to 0.0 to not bounce, 1.0 to bounce back up to original hight
        // and in-between to lose speed after bouncing.  Set to >1.0 to gain energy on each bounce
        "coefficient_of_restitution": <float>
    
        // used to minimize interpenetration of particles with the environment
        // note that this must be less than or equal to 1/2 block
        "collision_radius": <float>
    
        // triggers expiration on contact if true
        "expire_on_contact": <bool>
    
        // triggers an event
        // array of individual events
        "events": [
            {
              // triggers the specified event if the conditions are met
              "event": <string>
              // optional minimum speed for event triggering
              "min_speed": <float> // default/minimum is 2 blocks/sec
            },
        ],
        "events": { // can be an individual event as well
            // triggers the specified event if the conditions are met
            "event": <string>
            // optional minimum speed for event triggering
            "min_speed": <float> // default/minimum is 2 blocks/sec
        }
    }
    ```

22. # Particle Documentation - Particle Appearance Billboard component

    This component tells the particle system to render the particle as a billboard, a rectangle in the world facing a particular direction.

    JSON

    ```json
    "minecraft:particle_appearance_billboard": {
        // specifies the x/y size of the billboard
        // evaluated every frame
        "size": [<float/molang>, <float/molang>],
    
        // used to orient the billboard.  Options are:
        // "rotate_xyz" - aligned to the camera, perpendicular to the view axis
        // "rotate_y" - aligned to camera, but rotating around world y axis
        // "lookat_xyz" - aimed at the camera, biased towards world y up
        // "lookat_y" - aimed at the camera, but rotating around world y axis
        // "direction_x" - unrotated particle x axis is along the direction vector, unrotated y axis attempts to aim upwards
        // "direction_y" - unrotated particle y axis is along the direction vector, unrotated x axis attempts to aim upwards
        // "direction_z" - billboard face is along the direction vector, unrotated y axis attempts to aim upwards
     // emitter_transform_xy, // orient the particles to match the emitter's transform (the billboard plane will match the transform's xy plane).
     // emitter_transform_xz, // orient the particles to match the emitter's transform (the billboard plane will match the transform's xz plane).
     // emitter_transform_yz, // orient the particles to match the emitter's transform (the billboard plane will match the transform's yz plane).
    
        //"face_camera_mode": <string>
    
        // Specifies how to calculate the direction of a particle, this will be used by facing modes that require a direction as input (for instance: lookat_direction and direction)
        // Options are:
        // "derive_from_velocity" - The direction matches the direction of the velocity.
        // "custom_direction" - The direction is specified in the json definition using a vector of floats or molang expressions.
        // If the direction subsection is not defined, the default will be "derive_from_velocity" mode with a "min_speed_threshold" of 0.01.
        "direction": {
            "mode": "derive_from_velocity" or "custom_direction",
            "min_speed_threshold": <float> // only used in "derive_from_velocity" mode. The direction is set if the speed of the particle is above the threshold. The default is 0.01
            "custom_direction": [ <float/molang>, <float/molang>, <float/molang> ], // only used in "custom_direction" mode. Specifies the direction vector
        }
    
        // specifies the UVs for the particle.
        "uv": {
            // specifies the assumed texture width/height
            // defaults to 1
            // when set to 1, UV's work just like normalized UV's
            // when set to the texture width/height, this works like texels
            "texturewidth": <int>,
            "textureheight": <int>,
    
            // Assuming the specified texture width and height, use these
            // uv coordinates.
            // evaluated every frame
            "uv": [<float/molang>, <float/molang>],
            "uv_size": [<float/molang>, <float/molang>],
    
            // alternate way via specifying a flipbook animation
            // a flipbook animation uses pieces of the texture to animate, by stepping over time from one
            // "frame" to another
            "flipbook": {
                "base_UV": [ <float/molang>, <float/molang> ], // upper-left corner of starting UV patch
                "size_UV": [ <float>, <float> ], // size of UV patch
                "step_UV": [ <float>, <float> ], // how far to move the UV patch each frame
                "frames_per_second": <float>, // default frames per second
                "max_frame": <float/molang>, // maximum frame number, with first frame being frame 1
                "stretch_to_lifetime": <bool>, // optional, adjust fps to match lifetime of particle. default=false
                "loop":  <bool> // optional, makes the animation loop when it reaches the end? default=false
            }
        }
    }
    ```

23. # Particle Documentation - Particle Appearance Tinting component

    This component sets the color tinting of the particle.

    JSON

    ```json
    // color fields are special, they can be either an RGB, or a "#RRGGBB"
    // field (or RGBA or "AARRGGBB").  If RGB(A), the channels are
    // from 0 to 1.  If the string "#AARRGGBB", then the values are
    // hex from 00 to ff.
    //
    // this pseudo-type will be denoted by <color>
    "minecraft:particle_appearance_tinting": {
        // interpolation based color
        "color": {
            // an array of colors
            // there are two ways to specify the array of colors
            // the first method is to just have an array of colors
            // these will be interpreted to be equally spaced, with the entire
            // range going from 0 to 1
            //
            // the second option is to specify a value/color pair list
            // this will cause the colors to appear when their specified value
            // occurs in the interpolant, and interpolated in between.  Note
            // that this will be sorted
            "gradient": [ <color>, <color>, ...],
            "gradient": {
            <float>: <color>,
            <float>: <color>,
            ...
            }
            "interpolant": <float/molang> // hint: use a curve here!
        }
    
        // directly set the color
        "color": <color>
        // examples of direct color field:
        "color": "#ff0000"
        "color": [1, 0, 0]
    },
    ```

24. # Particle Documentation - Particle Appearance Lighting

    When this component exists, particle will be tinted by local lighting conditions in-game.

    JSON

    ```json
    "minecraft:particle_appearance_lighting": {}
    ```

25. # Particle Documentation - Particle Lifetime Expression component

    Standard lifetime component. These expressions control the lifetime of the particle.

    JSON

    ```json
    "minecraft:particle_lifetime_expression": {
        // this expression makes the particle expire when true (non-zero)
        // The float/expr is evaluated once per particle
        // evaluated every frame
        "expiration_expression": <float/molang> <default:0>
    
        // alternate way to express lifetime
        // particle will expire after this much time
        // evaluated once
        "max_lifetime": <float/molang>
    }
    ```

26. # Particle Documentation - Particle Lifetime Events component

    This component allows for triggering events based on various lifetime events.

    JSON

    ```json
    "minecraft:particle_lifetime_events": {
          // all events use the event names in the event section
          // all events can be either an array or a string
          "creation_event": [<string>, ...] // fires when the particle is created
          "creation_event": <string>
          "expiration_event": [<string>, ...] // fires when the particle expires (does not wait for particles to expire too)
          "expiration_event": <string>,
    
          // event timeline
          "timeline": {
            // a series of times, e.g. 0.0 or 1.0, that trigger the event
            // "time" is the time, e.g. one line might be:
            // "0.4": "event"
            "time": [<string>", ...]
            "time": <string>
          }
    }
    ```

27. # Particle Documentation - Particle Lifetime Kill-Plane component

    Particles that cross this plane expire. The plane is relative to the emitter, but oriented in world space. The four parameters are the usual 4 elements of a plane equation.

    JSON

    ```json
    // A*x + B*y + C*z + D = 0
    // with the parameters being [ A, B, C, D ]
    "minecraft:particle_kill_plane": [ <float>, <float>, <float>, <float> ]
    ```

28. # Particle Documentation - Particle Expire If In Blocks component

    Particles expire when in a block of the type in the list. Note: this component can exist alongside particle_lifetime_expression.

    JSON

    ```json
    "minecraft:particle_expire_if_in_blocks" [
        // minecraft block names, e.g. 'minecraft:water', 'minecraft:air'
        // these are typically the same name as in the /setblock command
        // except for the minecraft: prefix
        "blockname1",
        "blockname2",
        ...
    ],
    ```

29. # Particle Documentation - Particle Expire If Not In Blocks component

    Particles expire when in a block of the type not in the list.

     Note

    This component can exist alongside `particle_lifetime_expression`.

    JSON

    ```json
    "minecraft:particle_expire_if_not_in_blocks" [
        // minecraft block names, e.g. 'minecraft:water', 'minecraft:air'
        // these are typically the same name as in the /setblock command
        // except for the minecraft: prefix
        "blockname1",
        "blockname2",
        ...
    ],
    ```

## Example

1.Bouncing Bubbles

This particle effect generates a bunch of bubbles that bounce around.

JSON

```json
{
  "format_version": "1.10.0",
  "particle_effect": {
    "description": {
      "identifier": "minecraft:test_bounce",
      "basic_render_parameters": {
        "material": "particles_alpha",
        "texture": "textures/particle/particles"
      }
    },
    "components": {
      "minecraft:emitter_rate_instant": {
        "num_particles": 100
      },
      "minecraft:emitter_lifetime_once": {
        "active_time": 2
      },
      "minecraft:emitter_shape_sphere": {
        "offset": [ "Math.random(-0.5, 0.5)", "Math.random(-0.5, 0.5)", "Math.random(-0.5, 0.5)" ],
        "direction": "outwards",
        "radius": 1
      },
      "minecraft:particle_initial_speed": 5.0,
      "minecraft:particle_initial_spin": {
        "rotation": "Math.random(0, 360)",
        "rotation_rate": 0
      },
      "minecraft:particle_lifetime_expression": {
        "max_lifetime": "5"
      },
      "minecraft:particle_motion_dynamic": {
        "linear_acceleration": [ 0, -9.8, 0 ]
      },
      "minecraft:particle_motion_collision": {
        "coefficient_of_restitution": 0.5,
        "collision_drag": 4,
        "collision_radius": 0.1
      },
      "minecraft:particle_appearance_billboard": {
        "size": [ "0.1", "0.1" ],
        "facing_camera_mode": "lookat_xyz",
        "uv": {
          "texture_width": 128,
          "texture_height": 128,
          "uv": [ 0, 16 ],
          "uv_size": [ 8, 8 ]
        }
      },
      "minecraft:particle_appearance_lighting": {}
    }
  }
}
```

2. # Flame particle

   This particle is the little flame that appears on torches and furnaces to indicate fire. It is a simple particle, consisting of a non-moving flame, with some variations. Note the use of Molang to create variations in the particle behavior.

   In addition, the use of texture width/height in the UV section of the billboard component allows referencing of UVs via texels:

   JSON

   ```json
   {
     "format_version": "1.10.0",
     "particle_effect": {
       "description": {
         "identifier": "minecraft:basic_flame_particle",
         "basic_render_parameters": {
           "material": "particles_alpha",
           "texture": "textures/particle/particles"
         }
       },
       "components": {
         "minecraft:emitter_rate_instant": {
           "num_particles": 1
         },
         "minecraft:emitter_lifetime_expression": {
           "activation_expression": 1,
           "expiration_expression": 0
         },
         "minecraft:emitter_shape_sphere": {
           "radius": 0.025,
           "direction": [ 0, 0, 0 ]
         },
         "minecraft:particle_lifetime_expression": {
           "max_lifetime": "Math.random(0.6, 2.0)"
         },
         "minecraft:particle_appearance_billboard": {
           "size": [
             "(0.1 + variable.ParticleRandom1*0.1) - (0.1 * variable.ParticleAge)",
             "(0.1 + variable.ParticleRandom1*0.1) - (0.1 * variable.ParticleAge)"
           ],
           "facing_camera_mode": "lookat_xyz",
           "uv": {
             "texture_width": 128,
             "texture_height": 128,
             "uv": [ 0, 24 ],
             "uv_size": [ 8, 8 ]
           }
         }
       }
     }
   }
   ```

3.Materials

There are several material options available that determine how particles handle transparency and color blending.

| Name            | Description                                                  |
| :-------------- | :----------------------------------------------------------- |
| particles_add   | Enables color blending and transparency in colored pixels using an additive blend mode. |
| particles_alpha | Pixels with an alpha of 0 will be fully transparent, while colored pixels will always be opaque. |
| particles_blend | Enables color blending and transparency in colored pixels using a normal blend mode |

4.Mob Flame effect

The mob flame effect is used by the Blaze when it's charging up to hurl fireballs. This is a flip book flame effect that rises over time.

Unlike the earlier particles, this is a regular emitter. It is tied to an entity, thus uses the entity_aabb shape, as we want the flames to appear all over the blaze. As the effect is tied to the charged state, the activation expression is used, tied to the `EntityFlag::CHARGED` entity variable. This causes the flames to appear when the Blaze is charging, then to disappear when it isn't.

In this case, we use the texture width/height to make the texel "resolution" be one frame of animation, thus allowing advancement of the frames to be just 1:

JSON

```json
{
  "format_version": "1.10.0",
  "particle_effect": {
    "description": {
      "identifier": "minecraft:mobflame_emitter",
      "basic_render_parameters": {
        "material": "particles_alpha",
        "texture": "textures/flame_atlas"
      }
    },
    "components": {
      "minecraft:emitter_local_space": {
        "position": true,
        "rotation": true
      },
      "minecraft:emitter_rate_steady": {
        "spawn_rate": "Math.random(15, 25)",
        "max_particles": 50
      },
      "minecraft:emitter_lifetime_expression": {
        "activation_expression": 1,
        "expiration_expression": 0
      },
      "minecraft:emitter_shape_entity_aabb": {
        "direction": [ 0, 1, 0 ]
      },
      "minecraft:particle_initial_speed": "Math.random(0, 1)",
      "minecraft:particle_lifetime_expression": {
        "max_lifetime": 1.25
      },
      "minecraft:particle_motion_dynamic": {
        "linear_acceleration": [ 0, 1.0, 0 ],
        "linear_drag_coefficient": 0.0
      },
      "minecraft:particle_appearance_billboard": {
        "size": [ 0.5, 0.5 ],
        "facing_camera_mode": "lookat_xyz",
        "uv": {
          "texture_width": 1,
          "texture_height": 32,
          "flipbook": {
            "base_UV": [ 0, 0 ],
            "size_UV": [ 1, 1 ],
            "step_UV": [ 0, 1 ],
            "frames_per_second": 32,
            "max_frame": 32,
            "stretch_to_lifetime": true,
            "loop": false
          }
        }
      }
    }
  }
}
```

5. # Smoke particle

   This particle is the general-purpose smoke puff. It appears on torches, furnaces, Blazes, etc. It is a simple particle with an upward motion consisting of an upwards acceleration tempered by drag.

   The main feature of this particle different from the flame particle is the flipbook texture animation. See the details in the particle below, but the effect uses a flipbook subpart of the billboard appearance component to drive uv coordinates from frame to frame over time.

   In addition, the use of texture width/height in the UV section of the billboard component allows referencing of UVs via texels for the flipbook:

   JSON

   ```json
   {
     "format_version": "1.10.0",
     "particle_effect": {
       "description": {
         "identifier": "minecraft:basic_smoke_particle",
         "basic_render_parameters": {
           "material": "particles_alpha",
           "texture": "textures/particle/particles"
         }
       },
       "components": {
         "minecraft:emitter_rate_instant": {
           "num_particles": 1
         },
         "minecraft:emitter_lifetime_expression": {
           "activation_expression": 1,
           "expiration_expression": 0
         },
         "minecraft:emitter_shape_custom": {
           "offset": [ 0, 0, 0 ],
           "direction": [ "Math.random(-0.1, 0.1)", 1.0, "Math.random(-0.1, 0.1)" ]
         },
         "minecraft:particle_initial_speed": 1.0,
         "minecraft:particle_lifetime_expression": {
           "max_lifetime": "Math.random(0.4, 1.4)"
         },
         "minecraft:particle_motion_dynamic": {
           "linear_acceleration": [ 0, 0.4, 0 ]
         },
         "minecraft:particle_appearance_billboard": {
           "size": [ 0.1, 0.1 ],
           "facing_camera_mode": "lookat_xyz",
           "uv": {
             "texture_width": 128,
             "texture_height": 128,
             "flipbook": {
               "base_UV": [ 56, 0 ],
               "size_UV": [ 8, 8 ],
               "step_UV": [ -8, 0 ],
               "frames_per_second": 8,
               "max_frame": 8,
               "stretch_to_lifetime": true,
               "loop": false
             }
           }
         },
         "minecraft:particle_appearance_tinting": {
           "color": [ "variable.ParticleRandom1*0.5", "variable.ParticleRandom1*0.5", "variable.ParticleRandom1*0.5", 1.0 ]
         },
         "minecraft:particle_appearance_lighting": {}
       }
     }
   }
   ```

## Texture Set JSON and Introduction to Texture Sets

Minecraft: Bedrock Edition's Vibrant Visuals use a Physically Based Rendering (PBR) pipeline to simulate how materials react to realistic light behavior. This uses more texture data than just color, enabling richer, more realistic visuals. Using PBR, you can have layers for different specular reflections, emissivity, normal maps, and more, which goes beyond the classic color pipeline for Vanilla Minecraft. Texture Sets have been added as the feature for defining multiple PBR layers for a texture resource. Texture Sets are data driven from JSON files.



## Texture set JSON schema version 1.21.30

 Note

RTX-based resource packs will not make use of the `"metalness_emissive_roughness_subsurface"` field.

JSON

```JSON
{
  version "format_version"
  object "minecraft:texture_set"
  {
      color "color" : opt // Fill RGBA channels of a textureset layer with the specified values in an array or hex string
      string "color" : opt // The texture name of a textureset layer
      string "normal" : opt // The texture name of a textureset layer
      string "heightmap" : opt // The texture name of a textureset layer
      color "metalness_emissive_roughness" : opt // Fill RGB channels of a textureset layer with the specified values in an array or hex string
      string "metalness_emissive_roughness" : opt // The texture name of a textureset layer
      color "metalness_emissive_roughness_subsurface" : opt // Fill RGBA channels of a textureset layer with the specified values in an array or hex string
      string "metalness_emissive_roughness_subsurface" : opt // The texture name of a textureset layer
  }
}
```



## Layers

A **texture_set.json** file may specify several layers. Layers are references to texture image resources. They can also be defined in JSON as values for uniform solid values as an alternative to referencing texture images in a pack.



### Color

- This is an RGB 3-channel image (defaults to uniform alpha of 1.0), an RGBA 4-channel image, or a 4 value array for a uniform color with alpha.
- This is the only required layer.
- This is the only layer used by the Classic pipeline.
- There is typically lighting baked in the color image.



### Normal

- This is a 3-channel normal map image (or 4-channel where the 4th channel is ignored).
- This layer and the `heightmap` layer should not both be defined at the same time in a single Texture Set.



### Heightmap

- 1-channel layer image or a single value in the JSON file for a uniform heightmap.
- This layer and the `normal` layer should not both be defined at the same time in a single Texture Set.

 Caution

In Vibrant Visuals, heightmaps cannot be applied to texture-based objects such as items; normals should be used for this instead.



### Metalness_emissive_roughness

- This is a 3-channel image (or 4-channel where the 4th channel is ignored) or a 3-value array for a uniform MER.
- RGB images map Red to Metalness, Green to Emissive, and Blue to Roughness.
- This layer and the metalness_emissive_roughness_subsurface layer should not be defined at the same time in a single Texture Set.



### Metalness_emissive_roughness_subsurface

- This is a 4-channel image or a 4-value array for a uniform MERS.
- RGBA images map Red to Metalness, Green to Emissive, Blue to Roughness and Alpha to Subsurface.
- This layer and the metalness_emissive_roughness layer should not both be defined at the same time in a single Texture Set.
- This layer is only supported by Vibrant Visuals. It is not supported in RTX and any provided subsurface values will simply be ignored.
- Metalness and Subsurface properties cannot be utilized at the same time in a single Texture Set; they are mutually exclusive in this manner.
  - Only non-metals will be able to have sub surface scattering.
  - If a metalness_emissive_roughness_subsurface value is provided, either via image or uniform value, the higher value between metalness and subsurface will determine the predominant property. For example, a value of [64.0, 0.0, 0.0, 128.0] defines a non-metal surface with a sub-surface scattering value of 128, because the metalness value of 64 is the lesser of the two. A value of [255.0, 0.0, 0.0, 64.0] defines a metal surface with a sub-surface scattering value of 0, because the metalness value of 255 is the greater of the two. A tie favors subsurface.
  - While it is recommended to employ the metalness value as a binary operation (meaning a pixel is either metal or not), it is still possible to specify metalness as partially metal. Though this is not physically accurate, it can still be useful for obtaining certain styles/looks.



## Specifying uniform values

Instead of referencing a texture image for a Texture Set layer, values can instead be specified in the ***.texture_set.json** file, which is effectively the equivalent to referencing a texture image filled uniformly with that value or values for the respective channels.

The values in the JSON file can be specified in any of the following formats:

- 0 to 255 numeric range, or as a vector of such integers for a multichannel layer.
- Hexadecimal RGB or ARGB for 3 or 4 channels, or as 2 hex digits for a single channel layer.

 Caution

Texture variations using MERS uniform values in texture sets are not supported; an image-based MERS file must be provided for it to be applied properly.



## Examples of *.texture_set.json files

 Note

The layer values of a Texture Set JSON file can include a mix of references to image textures, hexadecimal, and numerical values.

JSON

```json
{
  "format_version": "1.16.100",
  "minecraft:texture_set": {
    "color": [ 180, 140, 190, 255 ],
    "metalness_emissive_roughness": "#FBA34C",
    "normal": "grass_carried_normal"
  }
}
```

This example uses referenced images that exist in the same folder. It uses a normal and MER map.

JSON

```json
{
  "format_version": "1.16.100",
  "minecraft:texture_set": {
    "color": "grass_carried",
    "metalness_emissive_roughness": "grass_carried_mer",
    "heightmap": "grass_carried_heightmap"
  }
}
```

You could also specify values of textures using numerical or hexadecimal values.

JSON

```json
{
  "format_version": "1.16.100",
  "minecraft:texture_set": {
    "color": [ 180, 135, 190, 170 ],
    "metalness_emissive_roughness": [ 130, 135, 140 ]
  }
}
```

This example makes use of the subsurface property in addition to MER.

JSON

```json
{
  "format_version": "1.21.30",
  "minecraft:texture_set": {
    "color": "cactus_side",
    "metalness_emissive_roughness_subsurface": "cactus_side_mers",
    "normal": "cactus_side_normal"
  }
}
```



## Invalid *.texture_set.json

If a Texture Set is invalid, `CONTENT_ERROR` will be logged and the Texture Set will not be used.

A Texture Set is invalid if:

- JSON data cannot be parsed, or doesn't meet the Texture Set schema.
- Color layer is not specified. Having a color layer in the **.texture_set.json** file is required.
- Both height map and normal layers are defined.
- A heightmap is being applied for a texture-based object.
- Both MER and MERS layers are defined.
- A referenced texture does not exist in the same resource pack or the referenced texture cannot be parsed.
- Any layer is defined with an unexpected number of channels:
  - For layers that are specified with referenced images: Color, MER, and Normal support 3 or 4 channel images; MERS supports 4 channel images; height map supports single-channel images only.
  - For layers that are specified with numerical or hexadecimal values: Color support 4-channel values; MER support 3-channel values; MERS support 4-channel values.



## Resource Stack Behavior

- Texture Set definitions can only reference images that exist in the same resource pack as the definition.
- Texture images in higher priority resource packs do not override a Texture Set's reference to a texture in its own pack.
- In the resource pack stack, Texture Set definitions for the same texture resource don't get merged. The higher priority pack's Texture Set definition will override the lower priority one.



## Referencing Texture Resources

If you have duplicate image references, the priority of file extensions is: **.tga > .png > .jpg > .jpeg**

For example, if **grass.png** and **grass.tga** both exist in the folder, then **grass.tga** will be chosen. This also applies to other data driven files, like actor JSON referencing a texture resource.